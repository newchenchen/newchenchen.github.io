<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>常见面试题目整理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="lock和synchronized的区别？1.从功能角度上来看，都是java中用来解决线程安全问题的一个工具 2.从特性来看,Synchronized是Java中的同步关键字;Lock是JUC包中提供的接口，这个接口有很多的实现类，其中包括ReentrantLock(可重入锁); Synchronized可以通过两种方式来控制锁的力度： 1.把synchronized关键字修饰在方法层面 2.修饰">
<meta property="og:type" content="article">
<meta property="og:title" content="常见面试题目整理">
<meta property="og:url" content="https://newchenchen.github.io/project/2022/05/20/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="lock和synchronized的区别？1.从功能角度上来看，都是java中用来解决线程安全问题的一个工具 2.从特性来看,Synchronized是Java中的同步关键字;Lock是JUC包中提供的接口，这个接口有很多的实现类，其中包括ReentrantLock(可重入锁); Synchronized可以通过两种方式来控制锁的力度： 1.把synchronized关键字修饰在方法层面 2.修饰">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="d:/Blog/source_posts/image-20220410184824609.png">
<meta property="og:image" content="d:/Blog/source_posts/image-20220410190612397.png">
<meta property="og:image" content="d:/Blog/source_posts/image-20220410190703632.png">
<meta property="og:image" content="d:/Blog/source_posts/image-20220410191132922.png">
<meta property="og:image" content="d:/Blog/source_posts/image-20220410191235061.png">
<meta property="og:image" content="d:/Blog/source_posts/image-20220411193714171.png">
<meta property="og:image" content="d:/Blog/source_posts/image-20220411210531942.png">
<meta property="og:image" content="d:/Blog/source_posts/image-20220519190146779.png">
<meta property="og:image" content="d:/Blog/source_posts/image-20220411193731060.png">
<meta property="og:image" content="d:/Blog/source_posts/image-20220411194000885.png">
<meta property="og:image" content="d:/Blog/source/_posts/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg">
<meta property="og:image" content="d:/Blog/source_posts/image-20220411205400814.png">
<meta property="article:published_time" content="2022-05-20T01:42:33.000Z">
<meta property="article:modified_time" content="2022-05-20T01:43:50.070Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/Blog/source_posts/image-20220410184824609.png">
  
    <link rel="alternate" href="/project/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/project/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/project/css/style.css">

  
    
<link rel="stylesheet" href="/project/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/project/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/project/">Home</a>
        
          <a class="main-nav-link" href="/project/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/project/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://newchenchen.github.io/project"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-常见面试题目整理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/project/2022/05/20/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2022-05-20T01:42:33.000Z" itemprop="datePublished">2022-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      常见面试题目整理
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="lock和synchronized的区别？"><a href="#lock和synchronized的区别？" class="headerlink" title="lock和synchronized的区别？"></a>lock和synchronized的区别？</h3><p>1.从功能角度上来看，都是java中用来解决线程安全问题的一个工具</p>
<p>2.从特性来看,Synchronized是Java中的同步关键字;Lock是JUC包中提供的接口，这个接口有很多的实现类，其中包括ReentrantLock(可重入锁);</p>
<p>Synchronized可以通过两种方式来控制锁的力度：</p>
<p>1.把synchronized关键字修饰在方法层面</p>
<p>2.修饰在代码块</p>
<p>并且可以通过Synchronized加锁对象的生命周期来控制锁的作用范围:</p>
<p>比如锁对象是静态对象或者是类对象，那么这个锁就是属于全局锁，如果锁对象是普通实例对象，那么这个锁的范围取决于这个实例的生命周期；</p>
<p>lock里锁的粒度是通过lock()方法和unlock()方法来决定的，包裹在两个方法之间的代码是可以保证线程安全的，而锁的作用域取决于lock实例的生命周期</p>
<p>Lock比Synchronized的灵活性更高</p>
<p>Lock可以自主决定什么时候加锁，什么时候释放锁</p>
<p>Lock还提供了非阻塞的竞争锁的方法trylock()这个方法可以通过返回true&#x2F;false来告诉当前线程是否已经有其他线程正在使用锁</p>
<p>而Synchronized由于是关键字，所以它无法去实现非阻塞竞争锁的方法；Synchronized锁的释放是被动的，就是当Synchronized同步代码块执行结束以后，或者代码出现异常的时候才会被释放；</p>
<p>lock提供了公平锁和非公平锁的机制</p>
<p>synchronized只提供了一种非公平锁的实现</p>
<p>3.从性能上来说，Synchronized和lock在性能方面相差不大，但是在实现上会有一定的区别,Synchronized引入了偏向锁、轻量级锁、重量级锁以及锁升级的机制来去实现锁的优化，而lock中则用到了自旋锁的方法去实现性能优化；</p>
<h3 id="公平锁和非公平锁的区别？"><a href="#公平锁和非公平锁的区别？" class="headerlink" title="公平锁和非公平锁的区别？"></a>公平锁和非公平锁的区别？</h3><p>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</p>
<p>优点：所有的线程都能得到资源，不会饿死在队列中。<br>缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。<br>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p>
<p>优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。<br>缺点：队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。</p>
<h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件:"></a>产生死锁的四个必要条件:</h3><p>（1） <strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</p>
<p>解决方案:无</p>
<p>（2） <strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>解决方案:可以一次性申请所有需要的资源来避免请求与保持条件；</p>
<p>（3） <strong>不剥夺条件</strong>:进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>解决方案:申请资源得不到时，主动释放当前获得的资源。</p>
<p>（4） <strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>解决方案:按序申请资源来预防,资源是有线性顺序的,先申请序号小的,再申请序号大的。所有的线程都遵循这样的规则就不会出现循环等待了。</p>
<h3 id="Redis和Mysql如何保证数据一致性问题？"><a href="#Redis和Mysql如何保证数据一致性问题？" class="headerlink" title="Redis和Mysql如何保证数据一致性问题？"></a>Redis和Mysql如何保证数据一致性问题？</h3><p>Redis是用来实现应用和数据库之间的一个读操作的缓存层，主要目的是去减少数据库的IO，还可以提升数据的IO性能，整体架构如下:</p>
<p><img src="D:\Blog\source_posts\image-20220410184824609.png" alt="image-20220410184824609"></p>
<p>当应用程序需要去读取某个数据的时候，首先会先尝试Redis里面去加载，如果命中了就直接返回，如果没有命中，就直接从数据库里面查询，查询到数据之后，再把数据缓存到Redis里面。<br>在这样一个架构里面会出现一个问题，就是一份数据同时保存在数据库和Redis里面，当数据发生变化的时候，需要同时去更新Redis和Mysql，由于更新操作是有先后顺序的，并且呢，它并不像Mysql中的多表事务操作可以满足ACID的特性，所以就会出现一个叫做数据一致性的问题。<br>能够选择的方法只有几种:</p>
<p>1.先更新数据库再更新缓存</p>
<p><img src="D:\Blog\source_posts\image-20220410190612397.png" alt="image-20220410190612397"></p>
<p>如果此时缓存更新失败，就会导致数据库和Redis中的数据是不一致的</p>
<p>2.先删除缓存再更新数据库</p>
<p><img src="D:\Blog\source_posts\image-20220410190703632.png" alt="image-20220410190703632"></p>
<p>理想情况下，是应用下次访问Redis的时候，发现Redis里面的数据是空的，那么就会从数据库加载保存到Redis里面，也就是说数据理论上是一致的。但是在极端情况下，由于删除Redis和更新数据库这两个操作并不是原子操作，所以在这个过程中，如果出现其它线程来访问，还是会存在数据不一致的问题。</p>
<p>所以如果需要在极端情况下依然保证Redis和Mysql的数据一致性，就只能采用最终一致性的方案，比如:基于RocketMQ的可靠性消息通信来实现数据的最终一致性</p>
<p><img src="D:\Blog\source_posts\image-20220410191132922.png" alt="image-20220410191132922"></p>
<p>还可以直接通过Canal组件监控Mysql中binlog的日志，把更新后的数据同步到Redis里面，因为这里是基于最终一致性来实现的，如果业务场景不能去接收数据的短期不一致性，那么就不能使用这样的一个方案来实现</p>
<p><img src="D:\Blog\source_posts\image-20220410191235061.png" alt="image-20220410191235061"></p>
<h3 id="常见的设计模式？"><a href="#常见的设计模式？" class="headerlink" title="常见的设计模式？"></a>常见的设计模式？</h3><h4 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a><strong>代理模式：</strong></h4><p>代理类和目标类实现同一个接口,代理类持有一个目标类对象,重写接口中方法时，调用目标类对象中的原有方法，此时可以完成对目标类方法的功能增加。</p>
<p><img src="D:\Blog\source_posts\image-20220411193714171.png" alt="image-20220411193714171"></p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式:"></a><strong>适配器模式:</strong></h4><p>适配器模式作为两个不兼容的接口之间的桥梁</p>
<p>适配器类实现了接口2，依赖接口1的实现类(适配器类中有接口1的引用作为成员变量)；</p>
<p>另一个接口2的实现类中有适配器类对象作为成员变量；</p>
<p>此时这个实现类本身实现接口2的功能方法,也可以通过适配器类对象调用接口1的功能方法；</p>
<p><img src="D:\Blog\source_posts\image-20220411210531942.png" alt="image-20220411210531942"></p>
<p><strong>关键代码:适配器继承或依赖已有的对象，实现想要的目标接口。</strong></p>
<p><strong>适配器模式的应用：</strong></p>
<p>创建线程的第三种方式:使用Callable接口,FutureTask实现 Runnable接口和Future接口,同时FutureTask依赖Callable接口的实现类,这里可以判定FutureTask为适配器类(依赖Callable接口的实现类,并且实现了Runnable接口);</p>
<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p> <img src="D:\Blog\source_posts\image-20220519190146779.png" alt="image-20220519190146779"></p>
<p>代理模式、适配器模式、装饰器模式很像</p>
<h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式:"></a><strong>模板模式:</strong></h4><p>继承一个抽象类时,重写其中的模板方法，行为由父类控制，但是子类来实现。</p>
<p><img src="D:\Blog\source_posts\image-20220411193731060.png" alt="image-20220411193731060"></p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式:"></a><strong>工厂模式:</strong></h4><p>一个接口有多个实现类，工厂类根据传入参数的不同返回不同的实现类,这些实现类都指向这个共同的接口引用(接口引用指向子类对象)。</p>
<p><img src="D:\Blog\source_posts\image-20220411194000885.png" alt="image-20220411194000885"></p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式:"></a><strong>抽象工厂模式:</strong></h4><p>创建一个抽象工厂类，里面有很多种工厂的抽象功能方法；</p>
<p>创建具体的工厂类来实现具体的这些功能方法；</p>
<p>创建工厂生成类,根据不同的参数，由这个类来创建不同的具体工厂类；</p>
<p>然后调用每个具体工厂类的具体功能方法；</p>
<img src="D:\Blog\source\_posts\3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg" alt="img"  />

<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式:"></a><strong>单例模式:</strong></h4><p>单例类的构造函数是私有的;</p>
<p>单例类有一个静态变量是单例类的一个对象。</p>
<p>get方法对外提供这一对象(静态方法中返回这个静态变量)</p>
<p>这个对象来调用类中的成员变量以及方法;</p>
<h5 id="1-DCL实现"><a href="#1-DCL实现" class="headerlink" title="1.DCL实现"></a>1.DCL实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pfinal <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE==<span class="literal">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-利用静态内部类的类加载机制来实现懒汉式单例，且保证了线程安全"><a href="#2-利用静态内部类的类加载机制来实现懒汉式单例，且保证了线程安全" class="headerlink" title="2.利用静态内部类的类加载机制来实现懒汉式单例，且保证了线程安全"></a>2.利用静态内部类的类加载机制来实现懒汉式单例，且保证了线程安全</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstace</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式:"></a><strong>桥接模式:</strong></h4><p>抽象化与实现化解耦，使得二者可以独立变化</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p><img src="D:\Blog\source_posts\image-20220411205400814.png" alt="image-20220411205400814"></p>
<p><strong>关键代码:抽象类依赖实现类</strong></p>
<p>抽象类中有一个接口引用作为成员变量</p>
<p>实现抽象类,根据实现类中构造方法传入参数的不同，实例化不同的接口引用；</p>
<p>接口引用指向具体的实现类；</p>
<h3 id="左连接，右连接，内连接，全连接的区别及使用"><a href="#左连接，右连接，内连接，全连接的区别及使用" class="headerlink" title="左连接，右连接，内连接，全连接的区别及使用"></a>左连接，右连接，内连接，全连接的区别及使用</h3><p>左连接 （left join）：返回包括左表的所有记录和右表中连接字段相等的记录<br>右连接（right join）：返回包括右表的所有记录和左表中连接字段相等的记录<br>等值连接或者叫内连接（inner join）：只返回两表相连相等的行<br>全外连接（full join）：返回左右表中所有的记录和左右表中连接字段相等的记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://newchenchen.github.io/project/2022/05/20/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/" data-id="cl3ds5yk80000l84s1ml09a8v" data-title="常见面试题目整理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/project/2022/05/20/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/project/archives/2022/05/">May 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/project/2022/05/20/%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86/">常见面试题目整理</a>
          </li>
        
          <li>
            <a href="/project/2022/05/20/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/project/" class="mobile-nav-link">Home</a>
  
    <a href="/project/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/project/js/jquery-3.4.1.min.js"></script>



  
<script src="/project/fancybox/jquery.fancybox.min.js"></script>




<script src="/project/js/script.js"></script>





  </div>
</body>
</html>